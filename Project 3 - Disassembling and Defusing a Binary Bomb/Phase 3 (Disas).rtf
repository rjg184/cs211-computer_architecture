{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww28600\viewh18000\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 This is a test.\
\
Breakpoint 1, 0x08048ce8 in phase_3 ()\
Missing separate debuginfos, use: debuginfo-install glibc-2.17-106.el7_2.8.i686\
(gdb) disas\
Dump of assembler code for function phase_3:\
=> 0x08048ce8 <+0>:	sub    $0x1c,%esp				<\'97 esp = esp - 28 \'97> esp = 1\
   0x08048ceb <+3>:	movl   $0x804a568,(%esp)			<\'97 copy 0x804a568 into esp \'97> esp = \'94He is evil and fits easily into most overhead storage bins."\
										\'930x804a568\'94 = \'94He is evil and fits easily into most overhead storage bins."\
   0x08048cf2 <+10>:	call   0x80491fb <string_length>\
   0x08048cf7 <+15>:	add    $0x1,%eax				<\'97 eax = eax + 1\
   0x08048cfa <+18>:	mov    %eax,(%esp)				<\'97 esp = eax\
   0x08048cfd <+21>:	call   0x8048870 <malloc@plt>		<\'97 \
   0x08048d02 <+26>:	movl   $0x69206548,(%eax)		<\'97 eax = 0x69206548         \'97 "He is evil and fits easily into most overhead storage bins."\
   0x08048d08 <+32>:	movl   $0x76652073,0x4(%eax)		<\'97 eax+4 = 0x76652073     \'97 "s evil and fits easily into most overhead storage bins."\
   0x08048d0f <+39>:	movl   $0x61206c69,0x8(%eax)		<\'97 eax+8 = 0x61206c69     \'97 "il and fits easily into most overhead storage bins."\
   0x08048d16 <+46>:	movl   $0x6620646e,0xc(%eax)		<\'97 eax+12 = 0x6620646e   \'97 "nd fits easily into most overhead storage bins."\
   0x08048d1d <+53>:	movl   $0x20737469,0x10(%eax)		<\'97 eax+16 = 0x20737469   \'97 \'93its easily into most overhead storage bins.\'94\
   0x08048d24 <+60>:	movl   $0x69736165,0x14(%eax)		<\'97 eax+20 = 0x69736165   \'97 \'93easily into most overhead storage bins.\'94\
   0x08048d2b <+67>:	movl   $0x6920796c,0x18(%eax)		<\'97 eax+24 = 0x6920796c   \'97 \'93ly into most overhead storage bins.\'94\
   0x08048d32 <+74>:	movl   $0x206f746e,0x1c(%eax)		<\'97 eax+28 = 0x206f746e    \'97 "nto most overhead storage bins.\'94\
   0x08048d39 <+81>:	movl   $0x74736f6d,0x20(%eax)		<\'97 eax+32 = 0x74736f6d    \'97  "most overhead storage bins.\'94\
   0x08048d40 <+88>:	movl   $0x65766f20,0x24(%eax)		<\'97 eax+36 = 0x65766f20    \'97 \'93 overhead storage bins.\'94\
   0x08048d47 <+95>:	movl   $0x61656872,0x28(%eax)		<\'97 eax+40 = 0x61656872   \'97 "rhead storage bins.\'94\
   0x08048d4e <+102>:	movl   $0x74732064,0x2c(%eax)		<\'97 eax+44 = 0x74732064   \'97 "d storage bins.\'94\
   0x08048d55 <+109>:	movl   $0x6761726f,0x30(%eax)		<\'97 eax+48 = 0x6761726f    \'97 \'93orage bins.\'94\
   0x08048d5c <+116>:	movl   $0x69622065,0x34(%eax)		<\'97 eax+52 = 0x69622065   \'97 \'93e bins.\'94\
   0x08048d63 <+123>:	movl   $0x2e736e,0x38(%eax)		<\'97 eax+56 = 0x2e736e       \'97 "ns."\
   0x08048d6a <+130>:	movb   $0x61,0x34(%eax)			<\'97 eax+52 = 97                   \'97 \'93a bins.\'94\
   0x08048d6e <+134>:	mov    %eax,0x4(%esp)			<\'97 esp+4 = eax                   \'97 "s evil and fits easily into most overhead storaga bins."\
   0x08048d72 <+138>:	mov    0x20(%esp),%eax			<\'97 eax = esp+32                 \'97 0x804d8c0 <input_strings+160>: "He is evil and fits easily into most overhead storage bins."\
   0x08048d76 <+142>:	mov    %eax,(%esp)				<\'97 esp = eax                       \'97 "\\300\\330\\004\\b(\\344\\004\\b\\a"\
   0x08048d79 <+145>:	call   0x804921a <strings_not_equal>	<\'97 \
   0x08048d7e <+150>:	test   %eax,%eax				<\'97 \
   0x08048d80 <+152>:	je     0x8048d87 <phase_3+159>\
   0x08048d82 <+154>:	call   0x8049515 <explode_bomb>\
   0x08048d87 <+159>:	add    $0x1c,%esp\
   0x08048d8a <+162>:	ret    \
End of assembler dump.\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
080491fb <string_length>:\
 80491fb:	8b 54 24 04          	mov    0x4(%esp),%edx			<\'97 edx = esp+4\
 80491ff:	80 3a 00             	cmpb   $0x0,(%edx)				<\'97 takes a byte that EDX points to (i. e. contains the address of) and compares it to zero\
 8049202:	74 10                	je     8049214 <string_length+0x19>	<\'97 if edx is EQUAL TO 0, then jump to line 8049214 \
 8049204:	b8 00 00 00 00       	mov    $0x0,%eax				<\'97 otherwise: eax = 0\
 8049209:	83 c0 01             	add    $0x1,%eax				<\'97 eax = eax + 1\
 804920c:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)		<\'97 takes a byte that EDX+EAX points to and compares it to zero\
 8049210:	75 f7                	jne    8049209 <string_length+0xe>	<\'97 if not equal, back to line 8049209\
 8049212:	f3 c3                	repz ret 					<\'97 return\
 8049214:	b8 00 00 00 00       	mov    $0x0,%eax				<\'97 assign eax = 0\
 8049219:	c3                   	ret   						<\'97 return\
\
0804921a <strings_not_equal>:\
 804921a:	57                   	push   %edi\
 804921b:	56                   	push   %esi\
 804921c:	53                   	push   %ebx\
 804921d:	83 ec 04             	sub    $0x4,%esp\
 8049220:	8b 5c 24 14          	mov    0x14(%esp),%ebx\
 8049224:	8b 74 24 18          	mov    0x18(%esp),%esi\
 8049228:	89 1c 24             	mov    %ebx,(%esp)\
 804922b:	e8 cb ff ff ff       	call   80491fb <string_length>\
 8049230:	89 c7                	mov    %eax,%edi\
 8049232:	89 34 24             	mov    %esi,(%esp)\
 8049235:	e8 c1 ff ff ff       	call   80491fb <string_length>\
 804923a:	ba 01 00 00 00       	mov    $0x1,%edx\
 804923f:	39 c7                	cmp    %eax,%edi\
 8049241:	75 3a                	jne    804927d <strings_not_equal+0x63>\
 8049243:	0f b6 03             	movzbl (%ebx),%eax\
 8049246:	84 c0                	test   %al,%al\
 8049248:	74 20                	je     804926a <strings_not_equal+0x50>\
 804924a:	3a 06                	cmp    (%esi),%al\
 804924c:	74 08                	je     8049256 <strings_not_equal+0x3c>\
 804924e:	66 90                	xchg   %ax,%ax\
 8049250:	eb 1f                	jmp    8049271 <strings_not_equal+0x57>\
 8049252:	3a 06                	cmp    (%esi),%al\
 8049254:	75 22                	jne    8049278 <strings_not_equal+0x5e>\
 8049256:	83 c3 01             	add    $0x1,%ebx\
 8049259:	83 c6 01             	add    $0x1,%esi\
 804925c:	0f b6 03             	movzbl (%ebx),%eax\
 804925f:	84 c0                	test   %al,%al\
 8049261:	75 ef                	jne    8049252 <strings_not_equal+0x38>\
 8049263:	ba 00 00 00 00       	mov    $0x0,%edx\
 8049268:	eb 13                	jmp    804927d <strings_not_equal+0x63>\
 804926a:	ba 00 00 00 00       	mov    $0x0,%edx\
 804926f:	eb 0c                	jmp    804927d <strings_not_equal+0x63>\
 8049271:	ba 01 00 00 00       	mov    $0x1,%edx\
 8049276:	eb 05                	jmp    804927d <strings_not_equal+0x63>\
 8049278:	ba 01 00 00 00       	mov    $0x1,%edx\
 804927d:	89 d0                	mov    %edx,%eax\
 804927f:	83 c4 04             	add    $0x4,%esp\
 8049282:	5b                   	pop    %ebx\
 8049283:	5e                   	pop    %esi\
 8049284:	5f                   	pop    %edi\
 8049285:	c3                   	ret    \
}